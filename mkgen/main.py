import re
import os
import glob
import json

# utils.py
def flat(t):
    return [item for sublist in t for item in sublist]


def fn_detect(lines):
    # Regex to extract paths from file lines

    fn_positions = []

    exp = r"(?:'|\")(.*?\/.*?\.[\w:]+.*)(?:'|\")"

    for line in lines:
        match = re.search(exp, line)

        if match:
            fn_positions.append(match.group(1))
        else:
            fn_positions.append(False)

    return fn_positions


def io_detect(path_positions):
    # Function to take a list of path positions and divide them into "inputs"
    # and "outputs"
    # DEV: doc and optimise this better

    # store index of True and distance from previous true in a tuple
    dist = []

    for i, position in enumerate(path_positions):

        if position:

            try:
                prev_position = dist[-1][0]
            except Exception:
                prev_position = 0

            dist.append((i, i - prev_position))

    # Find the highest distance
    max_gap = max([x[1] for x in dist])

    # Define the break point index between input and output groups
    break_point = [x[0] for x in dist if x[1] == max_gap][0] - 1

    # Split input and output indices
    inputs = [x[0] for x in dist if x[0] < break_point]

    outputs = [x[0] for x in dist if x[0] > break_point]

    return [inputs, outputs]

# config.py
def get_interpreter(config, file):

    config_extensions = [x["extensions"] for x in config["languages"]]

    file_ext = "." + file.split(".")[-1]

    language_index = [i for i, x in enumerate(config_extensions) if file_ext in x][0]

    return config["languages"][language_index]["interpreter"]

# makefile.py
def construct_target(file, fns, io, interpreter):

    name = file.split(".")[0].split("/")[-1]

    inputs = [fns[x] for x in io[0]]
    outputs = [fns[x] for x in io[1]]

    target = "\n" + name + ": " + " ".join(outputs) + "\n\n"

    target = target + " ".join(outputs) + ": " + file + " \ \n\t\t" + " \ \n\t\t".join(inputs) + "\n\t" + interpreter + "\n\n"

    return target


def get_code_files(config):

    extensions = flat([x["extensions"] for x in config["languages"]])

    code_files = []

    for src_path in config["src_paths"]:
        for ext in extensions:
            fns = glob.glob(os.getcwd() + "/" + src_path + "/*" + ext,
                            recursive=True)
            code_files.append(fns)

    return flat(code_files)

# makefile.py
def get_mkgen_indices(make_lines):

    start = [i for i, x in enumerate(make_lines) if x == "# -- mkgen targets start --\n"][0]
    end = [i for i, x in enumerate(make_lines) if x == "# -- mkgen targets end --\n"][0]

    return (start, end)

# makefile.py
def insert_new_targets(start, end, make_lines, targets):
    # remove lines between the auto generated annotations
    # and insert new targets between start and end indices

    return make_lines[:start+1] + targets + make_lines[end:]


def parse_code_file(config, file, lines):

    fns = fn_detect(lines)
    io = io_detect(fns)
    interpreter = get_interpreter(config, file)
    return construct_target(file, fns, io, interpreter)


def main():
    """
    Assumptions:
        1. os.getcwd() provides the root directory of the project.
        2. The root has a mkgen.json file.
        3. The root has a Makefile file with comments for autogenerated targets:
            * # -- mkgen targets start --
            * # -- mkgen targets end --
    """

    try:
        with open(os.getcwd() + "/mkgen.json") as f:
            config = json.load(f)
    except Exception:
        raise Exception("Unable to find mkgen.json file.")

    try:
        with open(os.getcwd() + "/Makefile", "r") as f:
            make_lines = f.readlines()
    except Exception:
        raise Exception("Unable to find Makefile file.")
    
    try:
        code_files = get_code_files(config)
    except Exception:
        raise Exception("Unable to locate files for parsing.")

    targets = []

    # looping through all project code files
    # extract this logic from main function later
    for file in code_files:

        try:
            with open(file, "r") as f:
                code_lines = f.readlines()
            targets.append(parse_code_file(config, file, code_lines))
        except Exception as e:
            print(f"Unable to parse { file } with Exception { str(e) }. Skipping.")
            pass

    start, end = get_mkgen_indices(make_lines)

    try:
        with open(os.getcwd() + "/Makefile", "w") as f:
            [f.write(x) for x in insert_new_targets(start, end, make_lines, targets)]
    except Exception:
        raise Exception("Unable to write new targets.")

    print(f"Wrote { len(targets) } new targets.")
